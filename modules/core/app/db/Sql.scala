package core.db

import collection.mutable
import core.common.Constant.DB._
import core.common.DBException
import core.utils.StringUtil

/**
 * Supported SQL types for Sql utility object.
 *
 * @author Clay Zhong
 * @version 1.0.0
 */
object SqlType extends Enumeration {
  val Select, Update, Delete = Value
}

/**
 * Supported SQL join type for Sql utility object.
 *
 * @author Clay Zhong
 * @version 1.0.0
 */
object JoinType extends Enumeration {
  val Inner, LeftOuter, RightOuter = Value
}

/**
 * Holds all SQL related information if the SQL is created by Sql utility object.
 *
 * @author Clay Zhong
 * @version 1.0.0
 */
case class SqlWrapper(var table: String,
                      var columns: String,
                      var joins: Option[mutable.ListBuffer[(String, String)]] = None,
                      var leftJoins: Option[mutable.ListBuffer[(String, String)]] = None,
                      var rightJoins: Option[mutable.ListBuffer[(String, String)]] = None,
                      var where: Option[String] = None,
                      var sort: Option[String] = None,
                      var set: Option[String] = None,
                      var sqlType: SqlType.Value = SqlType.Select) {

  /**
   * Get table alias name.
   *
   * @param table Table name.
   * @return String Table alias name.
   */
  def getAlias(table: String = this.table): String = {
    """(?i)(.*) as (.*)""".r.findFirstMatchIn(table) match {
      case Some(matchs) => matchs.group(2).trim
      case _ => table
    }
  }
}

/**
 * SQL utility class, all SQL created in this framework should be generated by this class.
 * It support both functional SQL and native SQL.
 *
 * More usages for this class can be found in: demo.models.DemoDao
 *
 * @author Clay Zhong
 * @version 1.0.0
 */
case class Sql[T <: Model](mapper: ModelMapper[T]) {
  /**
   * Holds all SQL related information for functional SQL.
   */
  var sqlWrapper: Option[SqlWrapper] = None

  /**
   * Native SQL which wrote by developer directly.
   */
  var nativeSql: Option[String] = None

  /**
   * Return data offset and limit, it will add 1 to limit for pagination.
   */
  var limits: (Int, Int) = (DEFAULT_QUERY_OFFSET, DEFAULT_QUERY_LIMIT + 1)

  /**
   * Save current join info when join/leftJoin/rightJoin methods been invoked.
   */
  private var currentJoinType: Option[JoinType.Value] = None
  private var currentJoinTable: Option[String] = None

  /**
   * Create a native SQL.
   *
   * @param sql Native SQL wrote by developer.
   * @return Sql[T] Current Sql object for using this native SQL.
   */
  def apply(sql: String): Sql[T] = {
    this.nativeSql = Some(sql)
    this
  }

  /**
   * Customized select columns if do not want to select all columns by default.
   *
   * @param columns Columns separated by comma.
   * @return Sql[T] Current Sql object.
   */
  def select(columns: String): Sql[T] = {
    this.getSqlWrapper.columns = columns
    this
  }

  /**
   * Choose different table for this Sql other than default model table.
   * This function is deprecated now, only allow to select from current Dao's model table.
   *
   * @param table Table name.
   * @return Sql[T] Current Sql object.
   */
  def from(table: String): Sql[T] = {
    this.getSqlWrapper.table = table
    this
  }

  /**
   * Add inner join table statement, table alias "AS" is supported.
   *
   * @param table Table name.
   * @return Sql[T] Current Sql object.
   */
  def join(table: String): Sql[T] = {
    if (this.getSqlWrapper.joins.isEmpty)
      this.getSqlWrapper.joins = Some(mutable.ListBuffer.empty[(String, String)])

    this.currentJoinType = Some(JoinType.Inner)
    this.currentJoinTable = Some(table)
    this
  }

  /**
   * Add left join table statement, table alias "AS" is supported.
   *
   * @param table Table name.
   * @return Sql[T] Current Sql object.
   */
  def leftJoin(table: String): Sql[T] = {
    if (this.getSqlWrapper.leftJoins.isEmpty)
      this.getSqlWrapper.leftJoins = Some(mutable.ListBuffer.empty[(String, String)])

    this.currentJoinType = Some(JoinType.LeftOuter)
    this.currentJoinTable = Some(table)
    this
  }

  /**
   * Add right join table statement, table alias "AS" is supported.
   *
   * @param table Table name.
   * @return Sql[T] Current Sql object.
   */
  def rightJoin(table: String): Sql[T] = {
    if (this.getSqlWrapper.rightJoins.isEmpty)
      this.getSqlWrapper.rightJoins = Some(mutable.ListBuffer.empty[(String, String)])

    this.currentJoinType = Some(JoinType.RightOuter)
    this.currentJoinTable = Some(table)
    this
  }

  /**
   * Add on conditions for join statement.
   *
   * @param on Table name.
   * @return Sql[T] Current Sql object.
   */
  def on(on: String): Sql[T] = {
    this.currentJoinType match {
      case Some(joinType) => joinType match {
        case JoinType.Inner => this.getSqlWrapper.joins.get += (this.currentJoinTable.get -> on)
        case JoinType.LeftOuter => this.getSqlWrapper.leftJoins.get += (this.currentJoinTable.get -> on)
        case JoinType.RightOuter => this.getSqlWrapper.rightJoins.get += (this.currentJoinTable.get -> on)
      }
      case _ => throw new DBException("Incorrect join statement found, missing join before on.")
    }

    this.currentJoinType = None
    this.currentJoinTable = None
    this
  }

  /**
   * Add SQL WHERE conditions for this Sql object.
   *
   * @param where SQL WHERE conditions.
   * @return Sql[T] Current Sql object.
   */
  def where(where: String): Sql[T] = {
    this.getSqlWrapper.where = this.getSqlWrapper.where match {
      case Some(value) => Some(value + " " + where)
      case _ => Some(where)
    }
    this
  }

  /**
   * Add SQL ORDER BY conditions for this Sql object.
   *
   * @param sort SQL ORDER BY conditions.
   * @return Sql[T] Current Sql object.
   */
  def order(sort: String): Sql[T] = {
    this.getSqlWrapper.sort = Some(sort)
    this
  }

  /**
   * Add SQL LIMIT conditions for this Sql object.
   *
   * @param limit SQL LIMIT condition with format (offset, limit).
   * @return Sql[T] Current Sql object.
   */
  def limit(limit: (Int, Int)): Sql[T] = {
    this.limits = (limit._1, if (LIMIT_ALL == limit._2) LIMIT_ALL else limit._2 + 1)
    this
  }

  /**
   * Add SQL LIMIT conditions for this Sql object.
   *
   * @param limit SQL LIMIT condition.
   * @return Sql[T] Current Sql object.
   */
  def limit(limit: Int): Sql[T] = {
    this.limits = (DEFAULT_QUERY_OFFSET, if (LIMIT_ALL == limit) LIMIT_ALL else limit + 1)
    this
  }

  /**
   * Change this SQL utility class to update type.
   *
   * This function is deprecated now because we do not want developer to batch update database which may cause uncertain risk.
   * If the data is too large, it will cause table lock for a long time.
   * And it will cause all cache expired because we do not know how many rows will been modified.
   *
   * @return Sql[T] Current Sql object.
   */
  def update: Sql[T] = {
    this.getSqlWrapper.sqlType = SqlType.Update
    this
  }

  /**
   * Add SQL SET statement for this Sql object.
   *
   * @param set SQL SET statement.
   * @return Sql[T] Current Sql object.
   */
  def set(set: String): Sql[T] = {
    this.getSqlWrapper.set = Some(set)
    this
  }

  /**
   * Change this SQL utility class to delete type.
   *
   * This function is deprecated now because we do not want developer to batch update database which may cause uncertain risk.
   * If the data is too large, it will cause table lock for a long time.
   * And it will cause all cache expired because we do not know how many rows will been modified.
   *
   * @return Sql[T] Current Sql object.
   */
  def delete: Sql[T] = {
    this.getSqlWrapper.sqlType = SqlType.Delete
    this
  }

  /**
   * Generate SQL statement according to current Sql utility object by functional SQL or native SQL.
   * It will check SQL legality, add del and limit automatically.
   *
   * @return String SQL statement to be executed in database.
   */
  def statement: String = {
    nativeSql match {
      case Some(value) =>
        // handle native SQL
        val sql = value.stripMargin.trim

        if (sql.endsWith(";")) sql
        else
          """(?i)\s*SELECT(.*)""".r.findFirstIn(sql) match {
            // select SQL, append limit condition
            case Some(_) => if (isLimitAll) sql else sql + " LIMIT %d, %d".format(limits._1, limits._2)
            // update, delete and other SQL
            case _ => sql
          }
      case _ =>
        // generate statement by SQL wrapper
        if (sqlWrapper.isEmpty) throw new DBException("SqlWrapper is undefined.")
        val wrapper = sqlWrapper.get

        wrapper.sqlType match {
          case SqlType.Select =>
            // generate select SQL
            var sql = "SELECT %s FROM %s ".format(wrapper.columns, wrapper.table)

            wrapper.joins.map(joins => joins.foreach(join => sql += "INNER JOIN %s ON %s ".format(join._1, join._2)))
            wrapper.leftJoins.map(joins => joins.foreach(join => sql += "LEFT JOIN %s ON %s ".format(join._1, join._2)))
            wrapper.rightJoins.map(joins => joins.foreach(join => sql += "RIGHT JOIN %s ON %s ".format(join._1, join._2)))

            sql += "WHERE %s ".format(wrapper.where match {
              case Some(value) =>
                if (StringUtil.isBlank(value))
                  " %s.del = false ".format(wrapper.getAlias())
                else
                  value + " AND %s.del = false ".format(wrapper.getAlias())
              case _ => " %s.del = false ".format(wrapper.getAlias())
            })

            if (wrapper.sort.isDefined) sql += "ORDER BY %s ".format(wrapper.sort.get)
            if (!isLimitAll) sql += "LIMIT %d, %d ".format(limits._1, limits._2)
            sql
          case SqlType.Update =>
            // generate update SQL
            if (wrapper.where.isEmpty) throw new DBException("Missing WHERE conditions in this SQL.")
            "UPDATE %s SET %s WHERE %s".format(wrapper.table, wrapper.set.get, wrapper.where.get)
          case SqlType.Delete =>
            // generate delete SQL
            if (wrapper.where.isEmpty) throw new DBException("Missing WHERE conditions in this SQL.")
            "DELETE FROM %s WHERE %s".format(wrapper.table, wrapper.where.get)
        }
    }
  }

  /**
   * Generate SQL count statement according to current Sql utility object by functional SQL.
   * It will check SQL legality and add del.
   * It does not support native SQL which wrote by developer.
   *
   * @return String SQL statement to be executed in database.
   */
  def countStatement: String = {
    if (sqlWrapper.isEmpty) throw new DBException("SqlWrapper is undefined.")
    val wrapper = sqlWrapper.get

    wrapper.sqlType match {
      case SqlType.Select =>
        // generate select count SQL
        var sql = "SELECT COUNT(*) as total FROM %s ".format(wrapper.table)

        wrapper.joins.map(joins => joins.foreach(join => sql += "INNER JOIN %s ON %s ".format(join._1, join._2)))
        wrapper.leftJoins.map(joins => joins.foreach(join => sql += "LEFT JOIN %s ON %s ".format(join._1, join._2)))
        wrapper.rightJoins.map(joins => joins.foreach(join => sql += "RIGHT JOIN %s ON %s ".format(join._1, join._2)))

        sql += "WHERE %s ".format(wrapper.where match {
          case Some(value) =>
            if (StringUtil.isBlank(value))
              " %s.del = false ".format(wrapper.getAlias())
            else
              value + " AND %s.del = false ".format(wrapper.getAlias())
          case _ => " %s.del = false ".format(wrapper.getAlias())
        })

        sql
      case _ => throw new DBException("Unsupported SQL statement for count data.")
    }
  }

  /**
   * Is query all data in current Sql utility object.
   *
   * @return Boolean Whether query all rows.
   */
  def isLimitAll: Boolean = LIMIT_ALL == this.limits._2

  /**
   * Get or create SQL wrapper for current Sql utility object.
   *
   * @return SqlWrapper SQL wrapper which holds all SQL related info for functional SQL.
   */
  private def getSqlWrapper: SqlWrapper = {
    if (sqlWrapper.isEmpty) sqlWrapper = Some(SqlWrapper(mapper.table, mapper.getColumns))
    sqlWrapper.get
  }
}
